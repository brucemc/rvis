extern crate glium;
use glium::{Surface};
//use glium::draw_parameters::PolygonMode::Line;
//use glium::vertex::VerticesSource::VertexBuffer;
//use glium::texture::UncompressedFloatFormat::F32F32F32F32;
//use glium::texture::MipmapsOption::AutoGeneratedMipmaps;

#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
}

implement_vertex!(Vertex, position);


#[derive(Copy, Clone)]
struct Colour {
    colour: f32,
}

implement_vertex!(Colour, colour);

pub struct Shader {
    fft_data: Option<Vec<f64>>,
    rows : usize,
    cols : usize,
    curr_row : usize,
    option : i32,
    scroll : i32,
    y_pos : f32,
    y_pos_d : f32,
    time : f32,
    vertex_buffer: glium::VertexBuffer<Vertex>,
    colour_buffer: glium::VertexBuffer<Colour>,
    colour_texture: glium::texture::texture1d::Texture1d,
    indicies: glium::IndexBuffer<u32>,
    program: glium::Program,
}

impl Shader {
    pub fn new(display: &glium::Display, rows: usize, cols: usize) -> Shader {
        let wf_size = 2 * rows * cols;
        let mut shape = vec![
            Vertex {
                position: [0.0, 0.0]
            };
            wf_size
        ];

        let colours = vec![
            Colour {
                colour: 0.0,
            };
            wf_size
        ];

        let mut ind = vec![0_u32; 6 * (2 * rows - 1) * (cols - 1)];

        let mut i: usize = 0;

        for r in 0..2*rows {
            let y = 2.0 - (4.0 * r as f32 / (2 * rows-1) as f32);
            for c in 0..cols {
                let x = 1.0 - (2.0 * c as f32 / (cols-1) as f32);
                shape[r * cols + c] = Vertex {
                    position: [x, y],
                };
                if c < cols - 1 && r < 2 * rows - 1 {
                    ind[i] = (r * cols + c) as u32;
                    ind[i + 1] = ((r + 1) * cols + c) as u32;
                    ind[i + 2] = ((r + 1) * cols + c + 1) as u32;

                    ind[i + 3] = (r * cols + c) as u32;
                    ind[i + 4] = ((r + 1) * cols + c + 1) as u32;
                    ind[i + 5] = (r * cols + c + 1) as u32;

                    i += 6;
                }
            }
        }

        let vertex_shader_src = r#"
          #version 450
          in vec2 position;
          in float colour;

          uniform int option;
          uniform int scroll;
          uniform float y_pos;
          uniform float time;

          out COLOURINT{
            float colour;
          } colourout;

          void main() {
            vec2 pos = position;

//            gl_Position = vec4(sin(time) * pos.x, pos.y+y_pos, 0.0, 1.0);
//            gl_Position = vec4(pos.x, pos.y+y_pos - 0.001, 0.0, 1.0);
//
            if (scroll == 1) {
              pos.y = pos.y+y_pos;
            }

            if (option == 1) {
              pos.x = sin(time / 3.0 ) * pos.x;
              pos.y = pos.y+sin(y_pos);
            }

            gl_Position = vec4(pos.x, pos.y, 0.0, 1.0);

            if (colour < 0.0) {
              colourout.colour = 0.0;
            }
            else if (colour > 1.0) {
              colourout.colour = 1.0;
            }
            else {
              colourout.colour = colour;
            }
          }
        "#;

        let fragment_shader_src = r#"
          #version 450
          out vec4 colour;

          in COLOURINT{
            float colour;
          } colourin;

          uniform sampler1D colour_texture;

          void main() {
              colour = texture(colour_texture, colourin.colour);
//              colour = vec4(0.0, colourin.colour, 0.0, 1.0);
          }
        "#;

        let program =
            glium::Program::from_source(display, vertex_shader_src, fragment_shader_src, None)
                .unwrap();

        let data = vec![
            (0.0, 0.0, 1.0),
            (1.0, 0.0, 0.0),
            (0.0, 1.0, 0.0),
            (1.0, 1.0, 0.0),
        ];

       // let data = vec![
       //     (0.0, 0.0, 1.0),
       //     (1.0, 0.0, 0.0),
       //     (0.0, 1.0, 0.0),
       //     (1.0, 1.0, 0.0),
       //     (0.0, 1.0, 0.0),
       //     (1.0, 0.0, 0.0),
       //     (0.0, 0.0, 1.0),
       // ];

       // let data = vec![
       //     (0.0, 0.0, 1.0),
       //     (1.0, 0.0, 0.0),
       //     (1.0, 1.0, 0.0),
//        ];
//        let data = vec![
//            (0.0, 0.0, 1.0),
//            (0.5, 0.0, 0.5),
//            (1.0, 0.0, 0.0),
//            (1.0, 0.0, 0.0),
//            (1.0, 0.0, 0.0),
//            (1.0, 0.0, 0.0),
//            (0.0, 0.0, 1.0),
//            (1.0, 0.0, 0.0),
//            (1.0, 0.0, 0.0),
//            (0.0, 1.0, 0.0),
//            (1.0, 0.0, 0.0),
//            (1.0, 0.0, 0.0),
//            (0.0, 0.0, 1.0),
//            (1.0, 0.0, 0.0),
//            (1.0, 0.0, 0.0),
//
//            (0.0, 0.0, 1.0),
//        ];
//        let data = vec![
//            (9.0, 0.0, 0.0),
//            (0.4, 0.4, 0.0),
//            (0.0, 0.4, 0.4),
//            (0.0, 0.9, 0.0),
//            (0.0, 0.4, 0.4),
//            (0.4, 0.4, 0.0),
//            (0.0, 0.0, 0.9),
//        ];

        Shader {
            fft_data: None,
            rows,
            cols,
            curr_row: 0,
            option: 1,
            scroll: 1,
            y_pos: 1.0,
            y_pos_d: -0.01,
            time: 0.0,
            vertex_buffer: glium::VertexBuffer::immutable(display, &shape).unwrap(),
            colour_buffer: glium::VertexBuffer::dynamic(display, &colours).unwrap(),
            colour_texture: glium::texture::Texture1d::new(display, data).unwrap(),
            indicies: glium::IndexBuffer::new(
                display,
                glium::index::PrimitiveType::TrianglesList,
                &ind,
            )
            .unwrap(),
            program,
        }
    }

    pub fn set_fft_data(&mut self, fft_data : &Vec<f64>) {
        self.fft_data = Some(fft_data.to_vec());
    }

    pub fn set_option(&mut self, option : i32) {
        self.option = option;
    }

    pub fn set_scroll(&mut self, scroll : i32) {
        self.scroll = scroll;
    }

    pub fn render(&mut self, target: &mut glium::framebuffer::SimpleFrameBuffer) {
        self.y_pos += self.y_pos_d;
        if self.y_pos <=  -1.0 {
            self.y_pos = 1.0;
        }

//        if self.y_pos <=  -1.0 {
////            self.y_pos = 1.0;
//            self.y_pos_d = self.y_pos_d * -1.0;
//            self.y_pos += self.y_pos_d;
//        }
//        else if self.y_pos >=  1.0 {
//            self.y_pos_d = self.y_pos_d * -1.0;
//            self.y_pos += self.y_pos_d;
//        }

        if let Some(fft_data) = &self.fft_data {
            let mut m = self.colour_buffer.map();
            self.curr_row = ((self.y_pos + 1.0) / 2.0 * self.rows as f32) as usize;
            if self.curr_row >= self.rows {
                self.curr_row = self.rows - 1;
            }

            for c in 0..self.cols {
                m[self.curr_row * self.cols + c] = Colour { colour: fft_data[c] as f32 };
                m[(self.curr_row + self.rows) * self.cols + c] = Colour { colour: fft_data[c] as f32 };
            }
            self.fft_data = None;
        }

        self.time += 0.01;

        let uniforms = uniform! {
          option: self.option,
          scroll: self.scroll,
          y_pos : self.y_pos,
          time: self.time,
          colour_texture : &self.colour_texture
        };

        let params = glium::DrawParameters {
//            polygon_mode: Line,
            .. Default::default()
        };
        target
            .draw(
                (&self.vertex_buffer, &self.colour_buffer),
                &self.indicies,
                &self.program,
                &uniforms,
                &params,
            )
            .unwrap();
    }
}
