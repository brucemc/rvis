extern crate glium;
use glium::{Surface};
// use glium::draw_parameters::PolygonMode::Line;
//use glium::vertex::VerticesSource::VertexBuffer;
//use glium::texture::UncompressedFloatFormat::F32F32F32F32;
//use glium::texture::MipmapsOption::AutoGeneratedMipmaps;

#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
}

implement_vertex!(Vertex, position);

pub struct Shader {
    vertex_buffer: glium::VertexBuffer<Vertex>,
    indicies: glium::IndexBuffer<u32>,
    program: glium::Program,
    time : f32,
}

impl Shader {
    pub fn new(display: &glium::Display) -> Shader {
        let shape = vec![
            Vertex { position: [-1.0, -1.0] },
            Vertex { position: [ 1.0, -1.0] },
            Vertex { position: [ 1.0,  1.0] },
            Vertex { position: [-1.0,  1.0] },
        ];

        let ind = vec![0, 1, 2, 0, 2, 3];


        let vertex_shader_src = r#"
          #version 450
          in vec2 position;

          void main() {
            gl_Position = vec4(position, 0.0, 1.0);
          }
        "#;

        let fragment_shader_src = r#"
        /*

            Shader derived from:

            Copyright (c) 2014, Eric Renaud-Houde (num3ric.com), MPC NY
            All rights reserved.

            Redistribution and use in source and binary forms, with or without
            modification, are permitted provided that the following conditions are met:

            1. Redistributions of source code must retain the above copyright notice, this
               list of conditions and the following disclaimer.
            2. Redistributions in binary form must reproduce the above copyright notice,
               this list of conditions and the following disclaimer in the documentation
               and/or other materials provided with the distribution.

            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
            ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
            WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
            DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
            ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
            (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
            ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
            (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
            SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

            The views and conclusions contained in the software and documentation are those
            of the authors and should not be interpreted as representing official policies,
            either expressed or implied, of the FreeBSD Project.
        */

        #version 140

        #define M_PI 3.1415926535897932384626433832795

        const int RECURSION_LEVEL = 3;
        const int MAX_RAY_BOUNCES = 80;
        const float cos30 = 0.8660254; // sqrt(3)/2
        const float EPS = 0.0000001;

        uniform float time;
        uniform sampler2D colour_texture;


        out vec4 fragColor;

        //! Ray emitted from the eye towards a particular sample.
        struct Ray
        {
            vec2 origin;
            vec2 dir;
            float len;
            int line_index; // current index of intersected triangle line
        };

        //! Line segment acting as a mirror: used for ray intersection & bounce.
        struct Line
        {
            vec2 start;
            vec2 end;
            vec2 normal;
        };

        //! Virtual kaleidoscope mirror triangle.
        struct Triangle {
            Line lines[3];
            vec2 vertices[3];
            vec2 center;
        };

        float cross2d( vec2 v0, vec2 v1 )
        {
            return v0.x * v1.y - v0.y * v1.x;
        }

        // Get the rotation matrix from an axis and an angle (in radians)
        mat3 rotationAxisAngle( vec3 v,  float a )
        {
            float si = sin( a );
            float co = cos( a );
            float ic = 1.0 - co;
            return mat3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,
                        v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,
                        v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );
        }

        vec2 mirror( vec2 point )
        {
            return mod(abs( point ), vec2(1.0));
        }

        vec2 scaleFrom( in vec2 coord, vec2 center, float factor )
        {
            vec2 transformed_coord = coord;
            transformed_coord -= center;
            transformed_coord *= factor;
            transformed_coord += center;
            return transformed_coord;
        }

        vec2 applyRotation( vec2 coord, vec2 center, float seconds )
        {
            float triangle_angle = M_PI / 3.0;
            float angle = seconds * triangle_angle;
            vec2 transformed_coord = coord;
            mat3 rot = rotationAxisAngle( vec3(0,0,1), angle );
            transformed_coord -= center;
            transformed_coord = (rot * vec3(transformed_coord, 0.0)).xy;
            transformed_coord += center;
            return transformed_coord;
        }

        bool intersect( vec2 p0, vec2 v0, vec2 p1, vec2 v1, out vec2 intersection )
        {
            float scalev0 = cross2d(p1 - p0, v1)/cross2d(v0, v1);
            float scalev1 = cross2d(p0 - p1, v0)/cross2d(v1, v0);
            if( cross2d( v0, v1 ) == 0.0 ) {
                return false;
            } else if( 0.0 < scalev0 && scalev0 < 1.0 && 0.0 < scalev1 && scalev1 < 1.0 ) {
                intersection = p0 + scalev0 * v0;
                return true;
            }
            return false;
        }

        void generateTriangle( in vec2 center, in float side, out Triangle triangle )
        {
            // Ray origin = eye center =  center of the kaleidoscope triangle
            triangle.center = center;

            float height = cos30 * side;
            // corners, starting at the bottom, counter-clockwise
            triangle.vertices[0] = vec2( center.x, center.y + 2.0/3.0 * height );
            triangle.vertices[1] = vec2( center.x - 0.5 * side, center.y - 1.0/3.0 * height );
            triangle.vertices[2] = vec2( center.x + 0.5 * side, center.y - 1.0/3.0 * height );

            triangle.lines[0].start  = triangle.vertices[0];
            triangle.lines[0].end    = triangle.vertices[1];
            triangle.lines[1].start  = triangle.vertices[1];
            triangle.lines[1].end    = triangle.vertices[2];
            triangle.lines[2].start  = triangle.vertices[2];
            triangle.lines[2].end    = triangle.vertices[0];

            // calculate edge orthogonal normals
            for( int i=0; i<3; i++ ) {
                triangle.lines[i].normal = vec2( triangle.lines[i].end - triangle.lines[i].start );
                triangle.lines[i].normal = normalize( vec2( -triangle.lines[i].normal.y, triangle.lines[i].normal.x ) );
            }
        }

        vec2 applyKaleidoscope( vec2 tc, Triangle triangle )
        {
            vec2 transformed = tc;

            Ray ray;
            //One horizontal pixel offset prevents intersection errors on bottom vertical corner
            ray.origin   = triangle.center;
            ray.dir      = tc - ray.origin;
            ray.len      = length( ray.dir );
            ray.line_index = -1;

            bool active_ray = true;
            // Maximum possible number of 100 ray bounces. The loop will almost always break before that.
            for( int nb=0; nb<MAX_RAY_BOUNCES; nb++ ) {
                // Iterate through triangle line segments
                for( int i=0; i<3; i++ ) {
                    // If the ray has bounced on a segment, we discard intersections with it
                    if( ray.line_index == i )
                        continue;
                    // Compute intersection from the ray to a triangle line segments
                    vec2 intersection;
                    if( intersect( ray.origin, ray.dir, triangle.lines[i].start, triangle.lines[i].end - triangle.lines[i].start, intersection ) ) {
                        float d = distance( ray.origin, intersection );
                        if( d < ray.len ) {
                            ray.dir = reflect( ray.dir, triangle.lines[i].normal );
                            ray.len = ray.len - d;
                            ray.origin = intersection;
                            ray.line_index = i;
                            transformed = ray.origin + normalize(ray.dir) * ray.len;
                        } else {
                            active_ray = false;
                        }
                        break;
                    }
                }
                if( ! active_ray ) break;
            }
            return transformed;
        }

        void main() {

            vec2 tc			= gl_FragCoord.xy;
            vec2 ScreenParams = vec2(800.0, 600.00);
//            float side      = 0.5 * max(ScreenParams.x * 2.0, 50.0);
            float side      = 300.0 * sin(time) + 600.0;
//            float side      = 800.0 * sin(time) + 600.0;
            float height    = cos30 * side;

            // Rotation center
            vec2 center     = vec2(0.5 * ScreenParams.x, 0.5 * ScreenParams.y + 200.0 * cos(time) );
            //vec2 tri_center = vec2( center.x + (400.0 + 400.0 * cos(2.0 * time)) * sin(2.0 * time), center.y - 0.66666 * cos30 * side );
//            vec2 tri_center = vec2( center.x + 200.0 + sin(2.0 * time), center.y - 0.66666 * cos30 * side );
            vec2 tri_center = vec2( center.x, center.y - 0.66666 * cos30 * side );
            // Triangle of line segments (mirrors) mimicking the interior of a kaleidoscope
            Triangle triangle;
            generateTriangle( tri_center, side, triangle );

            for( int i=0; i<RECURSION_LEVEL; i++ ) {
                tc = applyKaleidoscope( tc, triangle );
                tc = applyRotation( tc, center, 0.5 * time );
                tc = scaleFrom( tc, center, ScreenParams.y / height );
            }
            tc.y -= center.y;

            fragColor = texture( colour_texture, mirror( tc / ScreenParams.xy) );

        }
    "#;

        let program =
            glium::Program::from_source(display, vertex_shader_src, fragment_shader_src, None)
                .unwrap();

        Shader {
            vertex_buffer: glium::VertexBuffer::immutable(display, &shape).unwrap(),
            indicies: glium::IndexBuffer::new(
                display,
                glium::index::PrimitiveType::TrianglesList,
                &ind,
            )
            .unwrap(),
            program,
            time : 0.0,
        }
    }

    pub fn render(&mut self, target: &mut glium::Frame, texture: &glium::texture::Texture2d) {
        self.time += 0.003;
        let uniforms = uniform! { time: self.time, colour_texture : texture };
        let params = glium::DrawParameters {
//            polygon_mode: Line,
            .. Default::default()
        };
        target
            .draw(
                &self.vertex_buffer,
                &self.indicies,
                &self.program,
                &uniforms,
                &params,
            )
            .unwrap();
    }
}
